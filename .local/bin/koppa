#!/usr/bin/bash
#
# 0.1. basic functionality for ls|mk|mv
# @TODO: throw error when processing file if variable does not exist

xdg_cfg="${XDG_CONFIG_HOME:-$HOME/.config}"
cfg="${xdg_cfg}/koppa/config.json"
vars="${xdg_cfg}/koppa/variables.sh"

# used for filename matching
koppa_id="__"
ext_regex="(\.[a-zA-Z0-9\-_]{1,20})?"
# commented code that will change a hidden koppa file to unhidden
# .file__.ext > file.ext
unhide_cmd="koppa:unhide"

# colored output
tput_green="$(tput setaf 2)"
tput_blue="$(tput setaf 12)"
tput_red="$(tput setaf 1)"
tput_reset="$(tput sgr0)"

# TODO: check files before proceeding

# set shellcheck to avoid these errors
set -a
source "$vars"
set +a

# @args
# $1 input file path
write_file() {
  if [ -f "$1" ]; then
    # shellcheck disable=2016
    str_matching='$ENV{$1}'
    # shellcheck disable=2016
    str_err='"{ERR~$1}"'
    # shellcheck disable=2016
    str_hex='`bash -c "hex_to_rgb $ENV{$1}"`'
    str_syntax='%\{(\w+)\}%'
    str_rgb="--rgb"
    str_syntax_rgb="%\{(\w+)$str_rgb\}%"
    str_syntax_quoted='"!\{(\w+)\}!"'
    str_syntax_quoted_rgb="\"!\{(\w+)$str_rgb\}!\""
    str_code=$(cat "$1")

    # parse %{}% syntax
    str_code=$(echo "$str_code" | perl -p -e "s/$str_syntax_rgb/(exists $str_matching?$str_hex:$str_err)/eg")
    str_code=$(echo "$str_code" | perl -p -e "s/$str_syntax/(exists $str_matching?$str_matching:$str_err)/eg")

    # parse "!{}!" syntax
    str_code=$(echo "$str_code" | perl -p -e "s/$str_syntax_quoted_rgb/(exists $str_matching?$str_hex:$str_err)/eg")
    str_code=$(echo "$str_code" | perl -p -e "s/$str_syntax_quoted/(exists $str_matching?$str_matching:$str_err)/eg")

    # this both tests for existence of error, and prints
    if grep 'ERR' <<<"$str_code"; then
      echo "${tput_red}[ERROR]    $1${tput_reset}"
      exit 1
    fi

    # shellcheck disable=2001
    file_name=$(sed -E "s/(.*)($koppa_id)$ext_regex?$/\1\3/" <<<"$(basename "$1")")
    if tail "$1" 2>/dev/null | grep -q "$unhide_cmd"; then
      # shellcheck disable=2001
      file_name=$(sed 's/^\.//' <<<"$file_name")
    fi
    file_out="$(dirname "$1")/$file_name"

    # file needs to be deleted since it's write protected
    if [ -f "$file_out" ]; then
      rm -f "$file_out"
    fi

    echo "$str_code" >>"$file_out"
    chmod 444 "$file_out"
    echo "${tput_green}[write]${tput_reset}    $1 -> $file_out"
  fi
}

parse_files() {
  # ensure koppa_file is in config
  name=$1
  if ! obj_id=$(jq -e -r ".[] | select(.id==\"${name}\")" "$cfg"); then
    echo "\"${name}\" is not a key in: ${cfg}"
    exit
  fi

  # cd into directory and find files
  path=$(echo "$obj_id" | jq -e -r ".path")
  expanded_path=$(eval echo "$path")
  if [[ -d "$expanded_path" ]]; then
    # TODO: report error if can't cd
    cd "$expanded_path" || exit

    # TODO: allow depth setting in config... hardcoding depth for now
    # find files within directory
    koppa_files=$(find . -maxdepth 2 -regextype posix-extended -regex ".*${koppa_id}${ext_regex}$")

  else
    # in this case, a single file is passed TODO: allow multiple files
    koppa_files=("$expanded_path")
  fi

  echo "${tput_blue}==> $expanded_path${tput_reset}"

  # iterate and parse through files
  for koppa_file in $koppa_files; do
    write_file "$koppa_file"
  done

  # support for restarting a service/process
  if cmds=$(echo "$obj_id" | jq -e -r 'try .restart'); then
    args_string=$(echo "$cmds" | jq -r '. | join (" ")')
    args=("$args_string")
    # shellcheck disable=2068
    ${args[@]}
    ret=$?

    if [ $ret -eq 0 ]; then
      echo "${tput_green}[restart]${tput_reset} ${args[*]}"
    else
      echo "${tput_red}[failed] ${args[*]} ${tput_reset}"
    fi
  fi
}

case $1 in
ls)
  if [[ -z "$2" ]]; then
    jq -r '.[] | .id' "$cfg"

  else
    if jq -e ".[] | select(.id==\"$2\")" "$cfg" >/dev/null; then
      # XXX: using echo seems to excape color output
      jq -e ".[] | select(.id==\"$2\")" "$cfg"
    else
      echo "\"$2\" is not a key in: $cfg"
    fi
  fi
  ;;
mk)
  if [[ "$2" == "all" ]]; then
    all_keys=$(jq -r '.[].id' "$cfg")
    for key in $all_keys; do
      parse_files "$key"
    done
  else
    parse_files "$2"
  fi
  ;;
*)
  echo -e "Usage: $(basename "$0") <ls|mk> [args]\n"
  echo -e "Commands:\n\t ls [KEY]\t without arguments, list all KEYS. Show configuration for KEY."
  # echo -e " \t mv FILE\t rename FILE by toggling \"$koppa_id\" in filename (before extension)."
  echo -e " \t mk KEY|all\t builds all files for KEY, or for *all* KEYS."
  ;;
esac
