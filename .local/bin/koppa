#!/usr/bin/bash
#
# 0.1. basic functionality for ls|mk|mv

koppa_id="__"
xdg_cfg="${XDG_CONFIG_HOME:-$HOME/.config}"
cfg="${xdg_cfg}/koppa/config.json"
vars="${xdg_cfg}/koppa/variables.sh"

# TODO: check files before proceeding

# set shellcheck to avoid these errors
set -a
# shellcheck disable=1090
. "${vars}"
set +a

toggle_name() {
  input=$1

  # XXX: should match with same regex below (not chars not unique like Ïž)
  if [[ "$input" =~ $koppa_id ]]; then
    # shellcheck disable=2005
    echo "$(echo "$input" | sed -E 's/'"$koppa_id"'//')"
  else
    # TODO: best if we split the path/filename and only work on filename,
    # instead of the regex below which ensures /home/h/.xsettingsd works
    # shellcheck disable=2005
    echo "$(echo "$input" | sed -E 's/([^./])(\.[^.]+)?$/\1'"$koppa_id"'\2/')"
  fi
}

build_zap() {
  # ensure zap is in config
  name=$1
  if ! zap_obj=$(jq -e -r ".[] | select(.id==\"${name}\")" "$cfg"); then
    echo "\"${name}\" is not a key in: ${cfg}"
    exit
  fi

  # cd into directory and find files
  path=$(echo "$zap_obj" | jq -e -r ".path")
  expanded_path=$(eval echo "$path")
  if [[ -d "$expanded_path" ]]; then
    # TODO: report error if can't cd
    cd "$expanded_path" || exit

    # TODO: allow depth setting for find... hardcoding depth for now
    # find zap files within directory
    zaps=$(find . -maxdepth 2 -regextype posix-extended -regex ".*${koppa_id}(\.[a-zA-Z0-9\-_]{1,20})?$")

  else
    # in this case, a single file is passed TODO: allow multiple files
    zaps=$(toggle_name "$expanded_path")
  fi

  # iterate and parse through files
  for zap in $zaps; do
    perl -p -e 's/%\{\{(\w+)\}\}/(exists $ENV{$1}?$ENV{$1}:"{{ERR~$1}}")/eg' \
      < "$zap" > "${zap/${koppa_id}/}"
    echo "$name [file]: $zap -> ${zap/${koppa_id}/}"
  done

  # support for restarting services
  if systemd=$(echo "$zap_obj" | jq -e -r 'try .systemctl | join(" ")'); then
    args=("$systemd")
    # shellcheck disable=2068
    systemctl ${args[@]}
    echo "$name [service]: systemctl ${args[*]}"
  fi
}

case $1 in
  ls)
    if [[ -z "$2" ]]; then
      jq -r '.[] | .id' "$cfg"

    else
      if jq -e ".[] | select(.id==\"$2\")" "$cfg" > /dev/null; then
        # XXX: using echo seems to excape color output
        jq -e ".[] | select(.id==\"$2\")" "$cfg"
      else
        echo "\"$2\" is not a key in: $cfg"
      fi
    fi
    ;;
  mk)
    if [[ "$2" == "all" ]]; then
      all_keys=$(jq -r '.[].id' "$cfg")
      for key in $all_keys; do
        build_zap "$key"
      done
    else
      build_zap "$2"
    fi
    ;;
  mv)
    echo "$2 -> $(toggle_name "$2")"
    # XXX: should check for overwriting and warn
    mv "$2" "$(toggle_name "$2")"
    ;;
  *)
    echo -e "Usage: $(basename "$0") <ls|mk|mv> [args]\n"
    echo -e "Commands:\n\t ls [KEY]\t without arguments, list all KEYS. Show configuration for KEY."
    echo -e " \t mv FILE\t rename FILE by toggling \"$koppa_id\" in filename (before extension)."
    echo -e " \t mk KEY|all\t builds all files for KEY, or for *all* KEYS."
    ;;
esac
