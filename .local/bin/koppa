#!/usr/bin/bash
#
# 0.1. basic functionality for ls|mk|mv

koppa_id="__"
xdg_cfg="${XDG_CONFIG_HOME:-$HOME/.config}"
cfg="${xdg_cfg}/koppa/config.json"
vars="${xdg_cfg}/koppa/variables.sh"

# TODO: check files before proceeding

# set shellcheck to avoid these errors
set -a
# shellcheck disable=1090
. "${vars}"
set +a

toggle_name() {
  input=$1

  if [[ "$input" =~ $koppa_id ]]; then
    # shellcheck disable=2005
    echo "$(echo "$input" | sed -E 's/'"$koppa_id"'//')"
  else
    # TODO: best if we split the path/filename and only work on filename,
    # instead of the regex below which ensures /home/h/.xsettingsd works
    # shellcheck disable=2005
    echo "$(echo "$input" | sed -E 's/([^./])(\.[^.]+)?$/\1'"$koppa_id"'\2/')"
  fi
}

build_zap() {
  # ensure zap is in config
  name=$1
  if ! jq -e '. | has("'"$name"'")' "$cfg" &> /dev/null; then
    echo "\"${name}\" is not a key in: ${cfg}"
    exit
  fi

  zap_obj=$(jq '. | .'"$name" "$cfg")

  # cd into directory and find files
  path=$(echo "$zap_obj" | jq -e -r '.path')
  expanded_path=$(eval echo "$path")
  if [[ -d "$expanded_path" ]]; then
    # TODO: report error if can't cd
    cd "$expanded_path" || exit

    # TODO: allow depth setting for find... hardcoding depth for now
    # find zap files within directory
    zaps=$(find . -maxdepth 2 -regextype posix-extended -regex ".*${koppa_id}(\.[a-zA-Z0-9\-_]{1,20})?$")

  else
    # in this case, a single file is passed TODO: allow multiple files
    zaps=$(rename "$expanded_path")
  fi

  # iterate and parse through files
  for zap in $zaps; do
    perl -p -e 's/%\{\{(\w+)\}\}/(exists $ENV{$1}?$ENV{$1}:"{{ERR~$1}}")/eg' \
      < "$zap" > "${zap/${koppa_id}/}"
    echo "$name [file]: $zap -> ${zap/${koppa_id}/}"
  done

  # support for restarting services
  if systemd=$(echo "$zap_obj" | jq -e -r 'try .systemctl | join(" ")'); then
    args=("$systemd")
    # shellcheck disable=2068
    systemctl ${args[@]}
    echo "$name [service]: systemctl ${args[*]}"
  fi
}

case $1 in
  ls)
    if [[ -z "$2" ]]; then
      jq '. | keys' "$cfg"

    else
      if jq -e '.'"$2" "$cfg" > /dev/null; then
        # XXX: using echo seems to excape color output
        jq -e '.'"$2" "$cfg"
      else
        echo "\"$2\" is not a key in: $cfg"
      fi
    fi
    ;;
  mk)
    build_zap "$2"
    ;;
  mv)
    echo "$2 -> $(toggle_name $2)"
    # XXX: should check for overwriting and warn
    mv "$2" "$(toggle_name "$2")"
    ;;
  *)
    echo -e "Usage: $(basename "$0") <ls|mk|mv> [args]\n"
    echo -e "Commands:\n\t ls [KEY]\t without arguments, list all KEYS. Show configuration for KEY."
    echo -e " \t mv FILE\t rename FILE by toggling \""${koppa_id}"\" in filename (before extension)."
    echo -e " \t mk KEY|all\t builds all files for KEY, or for *all* KEYS."
    ;;
esac
